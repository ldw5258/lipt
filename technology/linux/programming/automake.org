# -*- org -*-

# Time-stamp: <2011-09-21 21:48:01 Wednesday by ldw>

#+OPTIONS: ^:nil author:nil timestamp:nil creator:nil H:3

#+STARTUP: indent

#+TITLE:Linux下Makefile的automake生成全攻略

#+AUTHOR:

#+STYLE: <link rel="stylesheet" type="text/css" href="/css/org.css" />
=======
# Time-stamp: <2011-09-22 17:39:16 Thursday by ldw>

#+OPTIONS: ^:nil author:nil timestamp:nil creator:nil H:2

#+STARTUP: indent


#+TITLE:  Linux 项目管理

#+STYLE: <link rel="stylesheet" type="text/css" href="/css/worg.css" />

#+begin_html
---
layout: org-default-3
title: Linux下Makefile的automake生成全攻略
---
#+end_html
** 简介

为Linux下的程序开发人员，大家一定都遇到 过Makefile，用make命令来编译自己写的程序确实是 很方便。一般情况下，大家都是手工写一个简单 Makefile，如果要想写出一个符合自由软件惯例的 Makefile就不那么容易了。                                                                          

在本文中，将给大家介绍如何使用 autoconf和automake两个工具来帮助我们自动地生成 符合自由软件惯例的Makefile，这样就可以象常见的 GNU程序一样，只要使用“./configure”，“make”， “make instal”就可以把程序安装到Linux系统中去了 。这将特别适合想做开放源代码软件的程序开发人员 ，又或如果你只是自己写些小的Toy程序，那么这个 文章对你也会有很大的帮助。                                                                        

** Makefile介绍

Makefile是用于自动编译和链接的，一个工程有 很多文件组成，每一个文件的改变都会导致工程的重 新链接，但是不是所有的文件都需要重新编译， Makefile中纪录有文件的信息，在make时会决定在链 接的时候需要重新编译哪些文件。                                                                    

Makefile的宗旨就是：让编译器知道要编译一个 文件需要依赖其他的哪些文件。当那些依赖文件有了 改变，编译器会自动的发现最终的生成文件已经过时 ，而重新编译相应的模块。

Makefile的基本结构不是很复杂，但当一个程序 开发人员开始写Makefile时，经常会怀疑自己写的是 否符合惯例，而且自己写的Makefile经常和自己的开 发环境相关联，当系统环境变量或路径发生了变化后 ，Makefile可能还要跟着修改。这样就造成了手工书 写Makefile的诸多问题，automake恰好能很好地帮助 我们解决这些问题。

使用automake，程序开发人员只需要写一些简单 的含有预定义宏的文件，由autoconf根据一个宏文件 生成configure，由automake根据另一个宏文件生成 Makefile.in，再使用configure依据Makefile.in来 生成一个符合惯例的Makefile。下面我们将详细介绍 Makefile的automake生成方法。

** 使用的环境

本文所提到的程序是基于Linux发行版本： Fedora Core release 1，它包含了我们要用到的 autoconf，automake。

** 从helloworld入手

我们从大家最常使用的例子程序helloworld开始 。

下面的过程如果简单地说来就是：                                                                


新建三个文件：

#+begin_src sh
                                        　　　helloworld.c                                                                                
                                        　　　configure.in                                                                                
                                        　　　Makefile.am
#+end_src

然后执行：                                                                                    

+---------------------------------------+
|aclocal; autoconf; automake            |
|--add-missing; ./configure; make; ./   |
|helloworld                             |
+---------------------------------------+                                                         

就可以看到Makefile被产生出来，而且可以将 helloworld.c编译通过。                                                                            

很简单吧，几条命令就可以做出一个符合惯例的 Makefile，感觉如何呀。                                                                            

现在开始介绍详细的过程：                                                                      

*** 建目录

在你的工作目录下建一个helloworld目录，我们 用它来存放helloworld程序及相关文件，如在/home/my/build下：                                                                                      
                                                                                                                                          
                                        |$ mkdir helloword                      |
                                        |$ cd helloworld                        |

*** helloworld.c
                                                                                                                                          
然后用你自己最喜欢的编辑器写一个 hellowrold.c文件，如命令：vi helloworld.c。使 用下面的代码作为helloworld.c的内容。                                                              
                                                                                                                                          
                                        |int main(int argc, char** argv)        |
                                        |{                                      |
                                        |printf("Hello, Linux World!\n");       |
                                        |return 0;                              |
                                        |}                                      |

完成后保存退出。                                                                              

　　现在在helloworld目录下就应该有一个你自己写
的helloworld.c了。

*** 生成configure

　　我们使用autoscan命令来帮助我们根据目录下的
源代码生成一个configure.in的模板文件。

　　命令：

#+begin_src sh
$autoscan
$ls                        
configure.scanhelloworld.c 
#+end_src

　　执行后在hellowrold目录下会生成一个文件：
configure.scan，我们可以拿它作为configure.in的
蓝本。

　　现在将configure.scan改名为configure.in，并
且编辑它，按下面的内容修改，去掉无关的语句：


#+begin_src sh
================configure.in内容开始================
#-*-Autoconf-*-
#Process this file with autoconf to produce aconfigure script.

AC_INIT(helloworld.c)                   
AM_INIT_AUTOMAKE(helloworld,1.0)        
                                         
#Checksforprograms.                     
AC_PROG_CC                              
                                        
#Checksforlibraries.                    
                                        
#Checksforheaderfiles.                  
                                         
#Checksfortypedefs,structures,and       
compilercharacteristics.                
                                         
#Checksforlibraryfunctions.             
AC_OUTPUT(Makefile)                     
==============configure.in内容结束=============
#+end_src

　　然后执行命令aclocal和autoconf，分别会产生 aclocal.m4及configure两个文件：
#+begin_src sh
$aclocal                           
$ls                               
aclocal.m4configure.inhelloworld.c 
$autoconf                          
$ls                                
aclocal.m4autom4te.cacheconfigure  
configure.inhelloworld.c           
#+end_src

　　大家可以看到configure.in内容是一些宏定义， 这些宏经autoconf处理后会变成检查系统特性、环境 变量、软件必须的参数的shell脚本。

　　autoconf是用来生成自动配置软件源代码脚本 （configure）的工具。configure脚本能独立于 autoconf运行，且在运行的过程中，不需要用户的干 预。

　　要生成configure文件，你必须告诉autoconf如 何找到你所用的宏。方式是使用aclocal程序来生成 你的aclocal.m4。

　　aclocal根据configure.in文件的内容，自动生 成aclocal.m4文件。aclocal是一个perl脚本程序， 它的定义是：“aclocal-createaclocal.m4by scanningconfigure.ac”。

　　autoconf从configure.in这个列举编译软件时所 需要各种参数的模板文件中创建configure。

　　autoconf需要GNUm4宏处理器来处理aclocal.m4 ，生成configure脚本。

m4是一个宏处理器。将输入拷贝到输出，同时将宏展开。宏可以是内嵌的，也可以是用户定义的。除了可以展开宏，m4还有一些内建的函数，用来引用文件，执行命令，整数运算，文本操作，循环等。m4既可以作为编译器的前端，也可以单独作为一个宏处理器。

*** 新建Makefile.am

　　新建Makefile.am文件，命令：

: $ vi Makefile.am


　　内容如下:
#+begin_src sh
AUTOMAKE_OPTIONS=foreign
bin_PROGRAMS=helloworld
helloworld_SOURCES=helloworld.c
#+end_src


　　automake会根据你写的Makefile.am来自动生成Makefile.in。

　　Makefile.am中定义的宏和目标,会指导automake生成指定的代码。例如，宏bin_PROGRAMS将导致编译和连接的目标被生成。

*** 　　运行automake

　　命令：

#+begin_src sh
$ automake --add-missing
configure.in: installing `./install-sh'
configure.in: installing `./mkinstalldirs'
configure.in: installing `./missing'
Makefile.am: installing `./depcomp'
#+end_src


utomake会根据Makefile.am文件产生一些文件，包含最重要的Makefile.in。

*** 执行configure生成Makefile

#+begin_src sh
$ ./configure
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking for gcc... gcc
checking for C compiler default output... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... no
checking for suffix of executables...
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for gcc option to accept ANSI C... none needed
checking for style of include used by make... GNU
checking dependency style of gcc... gcc3
configure: creating ./config.status
config.status: creating Makefile
config.status: executing depfiles commands
$ ls -l Makefile
-rw-rw-r-- 1 yutao yutao 15035 Oct 15 10:40 Makefile
#+end_src


　　你可以看到，此时Makefile已经产生出来了。

*** 使用Makefile编译代码

#+begin_src sh
$ make
if gcc -DPACKAGE_NAME="" -DPACKAGE_TARNAME="" -DPACKAGE_VERSION="" -

DPACKAGE_STRING="" -DPACKAGE_BUGREPORT="" -DPACKAGE="helloworld" -DVERSION="1.0"

-I. -I. -g -O2 -MT helloworld.o -MD -MP -MF ".deps/helloworld.Tpo" \
-c -o helloworld.o `test -f 'helloworld.c' || echo './'`helloworld.c; \
then mv -f ".deps/helloworld.Tpo" ".deps/helloworld.Po"; \
else rm -f ".deps/helloworld.Tpo"; exit 1; \
fi
gcc -g -O2 -o helloworld helloworld.o
#+end_src

　　运行helloworld

#+begin_src sh
$ ./helloworld
Hello, Linux World!
#+end_src

　　这样helloworld就编译出来了，你如果按上面的步骤来做的话，应该也会很容易地编译出正确的helloworld文件。你还可以试着使用一些其他的make命令，如make clean，make install，make dist，看看它们会给你什么样的效果。感觉如何？自己也能写出这么专业的Makefile，老板一定会对你刮目相看。


** 深入浅出

　　针对上面提到的各个命令，我们再做些详细的介绍。

*** autoscan

　　autoscan是用来扫描源代码目录生成configure.scan文件的。autoscan可以用目录名做为参数，但如果你不使用参数的话，那么 autoscan将认为使用的是当前目录。autoscan将扫描你所指定目录中的源文件，并创建configure.scan文件。

*** configure.scan

　　configure.scan包含了包含了系统配置的基本选项，里面都是一些宏定义。我们需要将它改名为configure.in
	

*** aclocal

　　aclocal是一个perl 脚本程序。aclocal根据configure.in文件的内容，自动生成aclocal.m4文件。aclocal的定义是：“aclocal - create aclocal.m4 by scanning configure.ac”。

*** autoconf

　　autoconf是用来产生configure文件的。configure是一个脚本，它能设置源程序来适应各种不同的操作系统平台，并且根据不同的系统来产生合适的Makefile，从而可以使你的源代码能在不同的操作系统平台上被编译出来。

　　configure.in文件的内容是一些宏，这些宏经过autoconf 处理后会变成检查系统特性、环境变量、软件必须的参数的shell脚本。configure.in文件中的宏的顺序并没有规定，但是你必须在所有宏的最前面和最后面分别加上AC_INIT宏和AC_OUTPUT宏。

　　在configure.ini中：

　　#号表示注释，这个宏后面的内容将被忽略。

: AC_INIT(FILE)

　　这个宏用来检查源代码所在的路径。

: AM_INIT_AUTOMAKE(PACKAGE, VERSION)

　　这个宏是必须的，它描述了我们将要生成的软件包的名字及其版本号：PACKAGE是软件包的名字，VERSION是版本号。当你使用make dist命令时，它会给你生成一个类似helloworld-1.0.tar.gz的软件发行包，其中就有对应的软件包的名字和版本号。

: AC_PROG_CC

　　这个宏将检查系统所用的C编译器。

: AC_OUTPUT(FILE)

　　这个宏是我们要输出的Makefile的名字。

　　我们在使用automake时，实际上还需要用到其他的一些宏，但我们可以用aclocal 来帮我们自动产生。执行aclocal后我们会得到aclocal.m4文件。

　　产生了configure.in和aclocal.m4 两个宏文件后，我们就可以使用autoconf来产生configure文件了。

*** Makefile.am

　　Makefile.am是用来生成Makefile.in的，需要你手工书写。Makefile.am中定义了一些内容：

: AUTOMAKE_OPTIONS

　　这个是automake的选项。在执行automake时，它会检查目录下是否存在标准GNU软件包中应具备的各种文件，例如AUTHORS、ChangeLog、NEWS等文件。我们将其设置成foreign时，automake会改用一般软件包的标准来检查。

: bin_PROGRAMS

　　这个是指定我们所要产生的可执行文件的文件名。如果你要产生多个可执行文件，那么在各个名字间用空格隔开。

: helloworld_SOURCES

　　这个是指定产生“helloworld”时所需要的源代码。如果它用到了多个源文件，那么请使用空格符号将它们隔开。比如需要 helloworld.h，helloworld.c那么请写成helloworld_SOURCES= helloworld.h helloworld.c。

　　如果你在bin_PROGRAMS定义了多个可执行文件，则对应每个可执行文件都要定义相对的filename_SOURCES。

*** automake

　　我们使用automake --add-missing来产生Makefile.in。

　　选项--add-missing的定义是“add missing standard files to package”，它会让automake加入一个标准的软件包所必须的一些文件。

　　我们用automake产生出来的Makefile.in文件是符合GNU Makefile惯例的，接下来我们只要执行configure这个shell 脚本就可以产生合适的 Makefile 文件了。

*** Makefile

　　在符合GNU Makefiel惯例的Makefile中，包含了一些基本的预先定义的操作：

+ make

　　根据Makefile编译源代码，连接，生成目标文件，可执行文件。

+ make clean

　　清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。

+ make install

　　将编译成功的可执行文件安装到系统目录中，一般为/usr/local/bin目录。

+ make dist

　　产生发布软件包文件（即distribution package）。这个命令将会将可执行文件及相关文件打包成一个tar.gz压缩的文件用来作为发布软件的软件包。

　　它会在当前目录下生成一个名字类似“PACKAGE-VERSION.tar.gz”的文件。PACKAGE和VERSION，是我们在configure.in中定义的AM_INIT_AUTOMAKE(PACKAGE, VERSION)。

+ make distcheck

　　生成发布软件包并对其进行测试检查，以确定发布包的正确性。这个操作将自动把压缩包文件解开，然后执行configure命令，并且执行make，来确认编译不出现错误，最后提示你软件包已经准备好，可以发布了。

#+begin_src sh
===============================================
helloworld-1.0.tar.gz is ready for distribution
===============================================
make distclean
#+end_src

　　类似make clean，但同时也将configure生成的文件全部删除掉，包括Makefile。

** 结束语

　　通过上面的介绍，你应该可以很容易地生成一个你自己的符合GNU惯例的Makefile文件及对应的项目文件。

　　如果你想写出更复杂的且符合惯例的Makefile，你可以参考一些开放代码的项目中的configure.in和Makefile.am文件，比如：嵌入式数据库sqlite，单元测试cppunit。
=======
title: Linux 项目管理
---
#+end_html

** 软件安装

: sudo aptitude install libtool autotool automake

** 来自automake手册的例子

目录结构:

#+begin_example
|-amhello
    |----- README
    |----- configure.ac
    |----- src
            |--- Makefile.am
            |--- hello.c
#+end_example

文件README的内容:

#+begin_example
This is a demonstration package for GNU Automake.
Type ‘info Automake’ to read the Automake manual.
#+end_example

文件configure.ac的内容:

#+begin_example
#                                               -*- Autoconf -*-
# Process this file with autoconf to produce a configure script.

AC_PREREQ([2.67])
AC_INIT([hello], [1.0], [ldw5258@126.com])
AC_CONFIG_SRCDIR([config.h.in])
AC_CONFIG_HEADERS([config.h])
AM_INIT_AUTOMAKE([-Wall -Werror foreign])

# Checks for programs.
AC_PROG_CC

# Checks for libraries.

# Checks for header files.

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.

AC_CONFIG_FILES([
Makefile
src/Makefile
])
AC_OUTPUT
#+end_example

文件src/Makefile.am的内容:

#+begin_example
bin_PROGRAMS = hello
hello_SOURCES = main.c
#+end_example


源文件src/hello.c的内容:

#+begin_src C
#include <config.h>
#include <stdio.h>
int main (int argc, char** argv)
{
    puts ("Hello World!");
    puts ("This is " PACKAGE_STRING ".");
    return 0;
}
#+end_src


运行命令:

#+begin_src sh
$ autoreconf --install
$ ./configure
$ make
$ src/hello
#+end_src

得到如下输出:

#+begin_src sh
Hello World!
This is helloworld 1.1 .
#+end_src


** hellworld 之 gtk


安装gtk开发包:

#+begin_src sh
$ sudo aptitude install libgtk2.0-dev
#+end_src

修改文件configure.ac,添加内容:


#+begin_example
AM_PATH_GTK_2_0(2.2.0,,AC_MSG_ERROR(gtkhello 0.1 needs GTK+ 2.2.0))
#+end_example

检查当前GTK版本是否符合要求.


向文件src/Makefile.am添加:

#+begin_example
gtkhello_SOURCES = gtkhello.c
AM_CPPFLAGS  = @GTK_CFLAGS@
LDADD = @GTK_LIBS@
#+end_example

添加文件gtkhello.c:

#+begin_src C
#include <gtk/gtk.h>

    int main(int argc, char *argv[]) {
    GtkWidget *wnd;
    GtkWidget *label;

    gtk_init(&argc, &argv);

    wnd = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(GTK_WINDOW(wnd), "Hello GTK+!");
    gtk_window_set_default_size(GTK_WINDOW(wnd), 300, 200);

    label = gtk_label_new("Hello, welcome to the GTK+ world in Ubuntu 9.10\n\n(C) 2010 Chinsoft Studio");
    gtk_container_add(GTK_CONTAINER(wnd), label);

    g_signal_connect(GTK_OBJECT(wnd), "destroy", G_CALLBACK(gtk_main_quit), NULL);

    gtk_widget_show_all(wnd);
    gtk_main();

    return 0;
}
#+end_src

执行命令:

#+begin_src sh
$ autoreconf --install
$ ./configure
$ make
$ src/gtkhello
#+end_src


